***

Jako zadaní jsme dostali jednoduchý [smart contract](https://en.wikipedia.org/wiki/Smart_contract), i se zdrojovým kodem.

```solidity
prgma solidity ^0.8.19;

contract Challenge {
	string private secret = "THM{}"
	bool private unlock_flag = false;
	uint256 private code;
	string private hint_text;

	constructor(string memory flag, string memory challenge_hint, uint256 challenge_code) {
		secret = flag;
		code = challenge code;
		hint_text = challenge_hint;
	}
	
	function hint() external view retunrs (string memory) {
		return hint_text;
	}

	function unlock(uint256 input) external returns (bool) {
		if (input == code) {
			unlock_flag = true;
			return true;
		}
		return false;
	}

	function isSolved() external view returns (bool) {
		return unlock_flag;
	}

	function getFlag() external view returns (string memory) {
		require(unlock_flag, "Challenge not solved yet");
		return secret;
	}
}
```

Dále je nám známa adresa hráčovi peněženky, privátní klíč, adresa kontraktu, port pomocí kterého budeme komunikovat s kontraktem, a ID řetězu.

Jako zadání je nám předloženo následující:
```plaintext
Goal" have the isSolved() function return true
```

***

Při analýze zdrojového kodu smart contractu zjistíme že nám stačí přečíst proměnou `code`, a vrátit jí zpět funkci `unlock`.
Pro interakci se smart contractem můžeme zvolit více možností, jako první se naskytne použití grafického rozhraní [REMIX IDE](https://remix.ethereum.org/). Z důvodu časového limitu jsem pro jistotu použil AI, které mě však grafickým rozhraním tohoto nástroje nedokáže provést přesně, nechal jsem si napsat javascript kod, který funkci vykoná.

```js
const { ethers } = require("ethers"); // Importuje ethers library

const RPC_URL = "http://10.10.40.14:8545";
const PRIVATE_KEY = "0xe80f4635a9ff18d6a69cd1d15834cefe7f18753a4613bbb2864c94280ac1daa7";
const CONTRACT_ADDRESS = "0x74dae0A0e456C8556525c7f16fB07CD9c25b2127";
const ABI = [
  {
    "inputs": [],
    "name": "engageMainSwitch",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "pressOverrideButton",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "isSolved",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "checkSystem",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  }
];

// --- SCRIPT LOGIC ---
async function main() {
  const provider = new ethers.JsonRpcProvider(RPC_URL);
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
  const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, wallet);

  // Step 1: Engage main switch
  console.log("Engaging main switch...");
  await contract.engageMainSwitch();

  // Step 2: Press override button
  console.log("Pressing override button...");
  await contract.pressOverrideButton();

  // Step 3: Check if solved
  const solved = await contract.isSolved();
  console.log("Solved:", solved);

  // Print system status
  const status = await contract.checkSystem();
  console.log("System status:", status);
}

main().catch(console.error);
```

***

Po spuštění kodu pomocí příkazové řádky v Linuxu.
```zsh
node solve-ctj.js
```
Nám vyjde platná vlajka.
```plaintext
THM{Industrial_Override_Activated}
```
